---
title: "Inconsistência Geo-PB"
date: "November 20, 2017"
output: 
    html_document:
        fig_height: 10
        fig_width: 13
---

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# Imports
library(knitr)
library(kableExtra)
library(tidyverse)
library(RPostgreSQL)
library(config)
#devtools::install_github("sicarul/xray")
library(xray)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# Criando conexão:
drv <- DBI::dbDriver("PostgreSQL")

con1 <- DBI::dbConnect(drv, 
  host = config::get("host"),
  port = config::get("port"),
  user = config::get("user"),
  password = config::get("password"),
  dbname = config::get("dbname1")
)

con2 <- DBI::dbConnect(drv, 
  host = config::get("host"),
  port = config::get("port"),
  user = config::get("user"),
  password = config::get("password"),
  dbname = config::get("dbname2")
)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# Importando dados:
acompanhamento <- dbGetQuery(con1, "select * from t_acompanhamento")
complexo <- dbGetQuery(con1, "select * from t_complexo")       
convenio <- dbGetQuery(con1, "select * from t_convenio")         
empenhos_medicao <- dbGetQuery(con1, "select * from t_empenhos_medicao")
endereco <- dbGetQuery(con1, "select * from t_endereco")    
ente <- dbGetQuery(con1, "select * from t_ente")         
evolucao <- dbGetQuery(con1, "select * from t_evolucao")
foto_acompanhamento <- dbGetQuery(con1, "select * from t_foto_acompanhamento")
foto_medicao <- dbGetQuery(con1, "select * from t_foto_medicao")
jurisdicionado_db1 <- dbGetQuery(con1, "select * from t_jurisdicionado")     
medicao <- dbGetQuery(con1, "select * from t_medicao")   
municipio <- dbGetQuery(con1, "select * from t_municipio")          
obra <- dbGetQuery(con1, "select * from t_obra")        
origem <- dbGetQuery(con1, "select * from t_origem")             
parameter_db1 <- dbGetQuery(con1, "select * from t_parameter")
permission_db1 <- dbGetQuery(con1, "select * from t_permission")        
pessoa_db1 <- dbGetQuery(con1, "select * from t_pessoa")      
pessoafisica_db1 <- dbGetQuery(con1, "select * from t_pessoafisica")     
pessoajuridica_db1 <- dbGetQuery(con1, "select * from t_pessoajuridica")     
profile_db1 <- dbGetQuery(con1, "select * from t_profile")   
profile_permission_db1 <- dbGetQuery(con1, "select * from t_profile_permission")
recurso_proprio <- dbGetQuery(con1, "select * from t_recurso_proprio")
regularidade <- dbGetQuery(con1, "select * from t_regularidade")  
tipo_jurisdicionado_db1 <- dbGetQuery(con1, "select * from t_tipo_jurisdicionado")
user_db1 <- dbGetQuery(con1, "select * from t_user")
user_api_db1 <- dbGetQuery(con1, "select * from t_user_api")
user_profile_db1 <- dbGetQuery(con1, "select * from t_user_profile")

play_evolutions <- dbGetQuery(con2, "select * from play_evolutions")
contato <- dbGetQuery(con2, "select * from t_contato")
endereco <- dbGetQuery(con2, "select * from t_endereco")
gestao <- dbGetQuery(con2, "select * from t_gestao")
jurisdicionado_db2 <- dbGetQuery(con2, "select * from t_jurisdicionado")
localidade <- dbGetQuery(con2, "select * from t_localidade")
parameter_db2 <- dbGetQuery(con2, "select * from t_parameter")
periodoresponsabilidade <- dbGetQuery(con2, "select * from t_periodoresponsabilidade")
permission_db2 <- dbGetQuery(con2, "select * from t_permission")
pessoa_db2 <- dbGetQuery(con2, "select * from t_pessoa")
pessoafisica_db2 <- dbGetQuery(con2, "select * from t_pessoafisica")
pessoajuridica_db2 <- dbGetQuery(con2, "select * from t_pessoajuridica")
profile_db2 <- dbGetQuery(con2, "select * from t_profile")
profile_permission_db2 <- dbGetQuery(con2, "select * from t_profile_permission")
resto_a_pagar_temp <- dbGetQuery(con2, "select * from t_resto_a_pagar_temp")
tipo_jurisdicionado_db2 <- dbGetQuery(con2, "select * from t_tipo_jurisdicionado")
user_db2 <- dbGetQuery(con2, "select * from t_user")
user_api_db2 <- dbGetQuery(con2, "select * from t_user_api")
user_profile_db2 <- dbGetQuery(con2, "select * from t_user_profile")

```

#### Descrição dos dados

Das tabelas existentes no banco de dados do TCE, apenas a de acompanhamento tem dados geo-referenciados, mas a principal tabela é a de obras, visto que estamos no escopo do Geo Obras.

Vejamos a tabela de obras:

```{r}
obra %>% 
    str()
```

Na tabela de obras existem 16 colunas, onde temos: 

* id                          : O próprio id da tabela
* fk_jurisdicionado           : uma chave estrangeira para a tabela jurisdicionado
* numero_contrato             : o número do contrato da obra
* numero_obra                 : o número da obra
* descricao_sucinta_obra      : a descrição sucinta da obra
* fk_localidade               : uma chave estrangeira para a tabela de localidade
* descricao_localidade        : a descrição da localidade
* fk_tipo_obra                : uma chave estrangeira para o tipo da obra
* fk_tipo_execucao            : uma chave estrangeira para o tipo de execução
* valor_obra                  : o valor da obra
* planilha_contratada         : uma referência para a planilha da obra?
* obra_incorporavel_patrimonio: um boolean que indica se a obra é incorporável ao patrimônio
* dimensao                    : a dimensão da obra
* numero_protocolo_tramita    : o número do protocolo tramita
* fk_complexo_obras           : uma chave estrangeira para o complexo da obra
* cancelled                   : um boolean que indica se a obra foi cancelada ou não

Como falado acima, existe uma foreign key para o jurisdicionado, mas a tabela de jurisdicionado do db vigia é vazia.

```{r}
jurisdicionado_db1 %>% count()
```

Com isso, ela provavelmente se refere à tabela do db cabobranco, visto que existem observações no segundo.

```{r}
jurisdicionado_db2 %>% count()
```

A chave estrangeira fk_tipo_obra não é encontrada em nenhuma outra tabela, assim como fk_tipo_execucao. Apesar de existir uma coluna planilha_contratada na tabela obras, não foi encontrada outra tabela que contenha estas planilhas.

Vejamos a tabela de localidade, referente a chave estrangeira de obras:

```{r}
localidade %>% 
    str()
```

Na tabela de localidades também existem 16 colunas, onde temos:

* id                : o id da tabela de localidades
* uf                : a unidade federativa da localidade
* codigo_uf         : o código da unidade federativa
* mesoregiao        : a mesoregião da localidade
* codigo_mesoregiao : o código da mesoregião
* microregiao       : a microregião da localidade
* codigo_microregiao: o código da microregião
* nome              : o nome da localidade
* codigo_ibge       : o código do IGBE
* codigo_siaf       : o código do SIAF
* link_ibge         : o link do IBGE
* bandeira          : a bandeira da localidade
* brasao            : o brasão da localidade
* link_wikipedia    : o link da wikipédia referente a localidade
* esfera            : a esfera da localidade
* cancelled         : um boolean que provavelmente indica se algo da localidade foi cancelado

Vejamos a tabela de jurisdicionados, referente à chave estrangeira de obras:

```{r}
jurisdicionado_db2 %>% 
    str()
```

Na tabela de jurisdicionados existem 12 colunas, onde temos:

* id                   : o id da tabela de jurisdicionados
* pessoajuridica       : provavelmente uma chave estrangeira para a tabela de pessoa jurídica
* poder                : um código que referencia algo ao poder do jurisdicionado
* tipojurisdicionado_fk: uma chave estrangeira que referencia a tabela de tipojurisdicionado
* localidade_fk        : uma chave estrangeira para a localidade
* nome                 : o nome do jurisdicionado
* codigo_sagres        : o código do SAGRES
* previdenciario       : um boolean que indica 
* municipio_importacao : o município da importação
* tramita_id           : o id do tramita
* cancelled            : um boolean que indica que algo relativo ao jurisdicionado foi cancelado 
* esfera               : a esfera da localidade

O nome do jurisdicionado parece coincidir com a unidade gestora do banco de dados do SAGRES.

Vejamos a tabela de complexos, referente à chave estrangeira de obras:

```{r}
complexo %>% 
    str()
```

Na tabela de complexos existem 5 colunas, onde temos:

* id       : o id da tabela
* descricao: a descrição do complexo
* tipo     : o tipo do complexo
* codigo   : o código do complexo
* cancelled: um boolean que indica que algo relativo ao complexo foi cancelado

Podemos ver que a tabela de complexo complementa a de obra, visto que tem o tipo da obra. Além disso, cada complexo é referenciado por mais de uma obra, como podemos ver a seguir pela diferenca entre a chave estrangeira em obras (existem 28681 linhas) e o id em complexos (existem 720 linhas):

```{r}
obra %>% 
    filter(!is.na(fk_complexo_obras)) %>% 
    nrow()

complexo %>% 
    nrow()
```

Vejamos a tabela de acompanhamento, a que de fato contém os pontos georeferenciados.

```{r}
acompanhamento %>% 
    str()
```

Na tabela de acompanhamentos existem 5 colunas, onde temos:

* id                      : o id do acompanhamento
* tipo                    : o tipo do acompanhamento
* tipo_georeferenciamento : o tipo do georeferenciamento
* valor_georeferenciamento: o valor do georeferenciamento
* fk_obra                 : a chave estrangeira para a obra
* cancelled               : um boolean que indica que algo relativo ao acompanhamento foi cancelado
* data_cadastro           : a data de cadastro do acompanhamento

Vejamos os tipos de acompanhamento

```{r}
acompanhamento %>% 
    arrange(valor_georeferenciamento) %>% 
    head() %>% 
    kable()

acompanhamento %>% 
    filter(tipo_georeferenciamento == 1) %>% 
    arrange(valor_georeferenciamento) %>% 
    head() %>% 
    kable()

acompanhamento %>% 
    filter(tipo_georeferenciamento == 2) %>% 
    head() %>% 
    kable()

acompanhamento %>% 
    filter(tipo_georeferenciamento == 3) %>% 
    head() %>% 
    kable()
```

Vemos que a geolocalização pode ser de quatro tipos, onde o 0 é quando não existe georeferenciamento, 1 é uma lista de pares latitude e longitude, o tipo 2 é uma referência para um arquivo KML, o qual não foi encontrado na base de dados, e o tipo 3 é apenas um par de latitude e longitude.

#### Inconsistência dos dados

Vejamos os dados faltantes na tabela de obras:

```{r}
anomalies.obra <- anomalies(obra)

anomalies.obra$variables %>% 
    kable()

anomalies.obra$problem_variables %>% 
    kable()
```

Vemos que exceto o número do protocolo tramita em que 0.05% das observações são nulas, nenhuma outra coluna tem observações nulas, porém a porcentagem de zeros chega a 97,36% na dimensão e 79,06% no valor da obra. Apesar de acusar 99,1% de zeros na coluna de obras canceladas, é uma coluna com tipo lógico, faz sentido que a maioria das obras não sejam canceladas, o que também acontece na coluna de obras incorporáveis ao patrimônio, onde acusa que 91,29% das obras tem valor zero.

Apesar da maioria das colunas não apresentarem valores nulos ou zeros, muitas delas possuem valores sem significado, por exemplo:

```{r}
obra %>% 
    group_by(numero_contrato) %>% 
    summarise(quantidade = n()) %>% 
    arrange(-quantidade) %>% 
    head() %>% 
    kable()
```

Existem 18567 números de contrato 0000, assim como 30 com valor "-".

Do mesmo modo, a coluna referente à descrição sucinta da obra tem alguns valores não nulos, mas sem significado:
```{r}
obras.sem.descricao <- obra %>% 
    filter(str_count(descricao_sucinta_obra, "[:alpha:]|[:blank:]") / nchar(descricao_sucinta_obra) < 0.6)

obras.sem.descricao %>% 
    select(id, fk_jurisdicionado, numero_contrato, numero_obra, descricao_sucinta_obra, fk_localidade) %>% 
    head() %>% 
    kable()
```

```{r}
(obras.sem.descricao %>% count()) / (obra %>% count()) * 100
```


Onde existem 1.5% de dados com mais de 40% da palavra composta por caracteres diferente do alfabeto.

Da mesma forma, a descrição da localidade tem vários valores sem significados:

```{r}
obras.sem.localidade <- obra %>% 
    filter(str_count(descricao_localidade, "[:alpha:]|[:blank:]") / nchar(descricao_localidade) < 0.6)

obras.sem.localidade %>% 
    select(id, fk_jurisdicionado, numero_contrato, numero_obra, descricao_sucinta_obra, fk_localidade) %>% 
    head() %>% 
    kable()

(obras.sem.localidade %>% count()) / (obra %>% count()) * 100
```

É possível ver que 1,58% das obras tem localidade composta por mais de 40% de caracteres diferente do alfabeto.

Vejamos os dados faltantes de jurisdicionados:

```{r}
anomalies.jurisdicionado <- anomalies(jurisdicionado_db2)

anomalies.jurisdicionado$variables %>% 
    kable()

anomalies.jurisdicionado$problem_variables %>% 
    kable()
```

Vemos que em 28,24% dos dados, o código do sagres é vazio e em 9,73% dos dados da esfera, 0,76% da chave estrangeira da localidade e 0,38% do município de importação são nulos. Da mesma forma que o anterior, as colunas previdenciario e cancelled são do tipo boolean, logo, faz sentido a maior parte deles terem apenas um valor.

Vejamos agora os dados das localidades:

```{r}
anomalies.localidade <- anomalies(localidade)

anomalies.localidade$variables %>% 
    kable()

anomalies.localidade$problem_variables %>% 
    kable()
```

Vemos que várias colunas da localidade tem 95,98% dos valores faltantes, como codigo_ibge, esfera, bandeira, brasao, link_ibge e link_wikipedia.

Agora pelo complexo:

```{r}
anomalies.complexo <- anomalies(complexo)

anomalies.complexo$variables %>% 
    kable()

anomalies.complexo$problem_variables %>% 
    kable()
```

Vemos que os dados de complexo parecem ser bem completos, não tendo dados faltantes, visto que a coluna cancelled é um boolean, onde nenhum complexo foi cancelado. Apesar disso, duas descrições não fazem sentido: 

```{r}
complexo %>% 
    filter(str_count(descricao, "[:alpha:]|[:blank:]") / nchar(descricao) < 0.6) %>% 
    kable()
```

Além disso, é possível ver que existe que várias obras referenciam um mesmo complexo. Podemos ver a seguir os complexos com mais obras:

```{r}
obra %>% 
    group_by(fk_complexo_obras) %>% 
    summarise(quantidade = n()) %>% 
    arrange(-quantidade) %>% 
    head() %>% 
    left_join(complexo, by = c("fk_complexo_obras" = "id")) %>% 
    kable()
```

Vemos que o complexo com mais obras é fictício, visto que a descrição é IMPORTAÇÃO GEOPB.

Por último, vejamos os dados faltantes da tabela de acompanhamento:

```{r}
anomalies.acompanhamento <- anomalies(acompanhamento)

anomalies.acompanhamento$variables %>% 
    kable()

anomalies.acompanhamento$problem_variables %>% 
    kable()
```

Vemos que tanto o tipo do georeferenciamento, quanto o valor do mesmo em 98,9% das linhas tem valor igual a zero.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
dbDisconnect(con1)
dbDisconnect(con2)
```



```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

######################################TRATANDO OS DADOS E JUNTANDO AS TABELAS######################################

UM_MILHAO = 1000000

jurisdicionado_db2_filtrado <- 
    jurisdicionado_db2 %>% 
    select(id, nome)


localidade_filtrado <-
    localidade %>% 
    select(mesoregiao, microregiao, nome, id) %>%
    mutate(municipio = nome) %>%
    select(-nome)

obra_filtrado <- 
    obra %>%
    select(fk_jurisdicionado, fk_localidade, descricao_localidade, descricao_sucinta_obra, valor_obra)


join_obras_jurisdicionado <- 
    base::merge(x = obra_filtrado, y = jurisdicionado_db2_filtrado, by.x = "fk_jurisdicionado", by.y = "id") %>%
    select(-fk_jurisdicionado)

join_obras_jurisdicionado <-
    base::merge(join_obras_jurisdicionado, localidade_filtrado, by.x="fk_localidade", by.y="id") %>%
    select(-fk_localidade)

######################################CRIANDO OS DATASETS QUE SERÃO PLOTADOS######################################

obras_por_mesoregiao <-
    join_obras_jurisdicionado %>% 
    group_by(mesoregiao) %>% 
    summarize(total_obras = sum(valor_obra))


obras_por_microregiao <-
    join_obras_jurisdicionado %>% 
    group_by(microregiao) %>% 
    summarize(total_obras = sum(valor_obra))

obras_por_municipio_top20 <-
    join_obras_jurisdicionado %>% 
    group_by(municipio) %>% 
    summarize(total_obras = sum(valor_obra)) %>% 
    top_n(20)

obras_por_orgao_top20 <-
    join_obras_jurisdicionado %>% 
    group_by(nome) %>% 
    summarize(total_obras = sum(valor_obra)) %>% 
    top_n(20)

obras_por_orgao_quantidade_top20 <-
    plyr::count(join_obras_jurisdicionado, 'municipio') %>%
    top_n(20)

outliers_borborema <-
    join_obras_jurisdicionado %>%
    filter(mesoregiao == "Borborema" & log(valor_obra) > 16)

outliers_sertao <-
    join_obras_jurisdicionado %>%
    filter(mesoregiao == "Sertão Paraibano" & log(valor_obra) > 16)

outliers_mata <-
    join_obras_jurisdicionado %>%
    filter(mesoregiao == "Mata Paraibana" & log(valor_obra) > 17)

outliers_agreste <-
    join_obras_jurisdicionado %>%
    filter(mesoregiao == "Agreste Paraibano" & log(valor_obra) > 16)

outliers <- rbind(outliers_agreste, outliers_borborema, outliers_mata, outliers_sertao)

mediana_mesoregiao <-
    join_obras_jurisdicionado %>%
    filter(valor_obra > UM_MILHAO) %>%
    group_by(mesoregiao) %>%
    summarise(mediana = median(valor_obra))

mediana_microregiao <-
    join_obras_jurisdicionado %>%
    filter(valor_obra > UM_MILHAO) %>%
    group_by(microregiao) %>%
    summarise(mediana = median(valor_obra))


getMedianaMicro <- function(microregiao) {
    mediana <- mediana_microregiao$mediana[mediana_microregiao$microregiao == microregiao]
    return(format(mediana/UM_MILHAO, digits = 2))
}

getMedianaMeso <- function(mesoregiao) {
    mediana <- mediana_mesoregiao$mediana[mediana_mesoregiao$mesoregiao == mesoregiao]
    return(format(mediana/UM_MILHAO, digits = 2))
}

breakString <- function(s) {
    s <- trimws(s)
    return(gsub('(.{1,45})(\\s|$)', '\\1\n', s))
}

```


<h1>Obras com valores extremos</h1>

Faremos agora uma análise sobre as obras que possuem valores distoantes das demais. Para isso vamos visualizar alguns gráficos para tentar entender melhor onde podem estar esses valores extremos.<br>


```{r}
######################################PLOTANDO OS FRÁFICOS######################################

obras_por_mesoregiao %>%
    filter(total_obras != 0) %>%
    mutate(total_obras = total_obras/ UM_MILHAO) %>%
    ggplot(aes(x = reorder(mesoregiao, -total_obras), y = total_obras)) + 
    geom_col() + 
    labs(title = "Gastos com obras por mesorregião", x="Mesorregião", y = "Valor gasto (milhões de R$)")
```



```{r}
obras_por_microregiao %>%
    filter(total_obras != 0) %>%
    mutate(total_obras = total_obras/ UM_MILHAO) %>%
    ggplot(aes(x = reorder(microregiao, -total_obras), y = total_obras)) + 
    geom_col() + 
    labs(title = "Gastos com obras por microrregião", x="Microrregião", y = "Valor gasto (milhões de R$)") + 
    coord_flip()
```


```{r message=FALSE, warning=FALSE, paged.print=FALSE}
obras_por_municipio_top20 %>%
    filter(total_obras != 0) %>%
    mutate(total_obras = total_obras/ UM_MILHAO) %>%
    ggplot(aes(x = reorder(municipio, -total_obras), y = total_obras)) + 
    geom_col() + 
    labs(title = "Top 20 dos municípios que mais gastam", x="Município", y = "Valor gasto (milhões de R$)") + 
    coord_flip()

```


```{r message=FALSE, warning=FALSE, paged.print=FALSE}
obras_por_orgao_top20 %>%
    filter(total_obras != 0) %>%
    mutate(total_obras = total_obras/ UM_MILHAO) %>%
    ggplot(aes(x = reorder(nome, -total_obras), y = total_obras)) + 
    geom_col() + 
    labs(title = "Top 20 dos orgãos públicos que mais gastam", x="Orgão", y = "Valor gasto (milhões de R$)") + 
    coord_flip()
```


```{r message=FALSE, warning=FALSE, paged.print=FALSE}
obras_por_orgao_quantidade_top20 %>%
    ggplot(aes(x = reorder(municipio, -freq), y = freq)) + 
    geom_col() + 
    coord_flip() +
    labs(title = "Top 20 dos orgãos públicos com maior quantidade de obras", x="Orgão", y = "Número de obras")
```


```{r message=FALSE, warning=FALSE, paged.print=FALSE}
plotly::plot_ly(
    join_obras_jurisdicionado %>% filter(valor_obra > UM_MILHAO) %>% group_by(mesoregiao),
    x = ~mesoregiao,
    y = ~log(valor_obra),
    color = ~mesoregiao,
    type = "box",
    boxpoints = "suspectedoutliers"
) %>%
    plotly::layout(title = "Obras com valores extremos (considerando apenas obras com valor maior que um milhão)", xaxis=list(title="Mesorregião"), yaxis=list(title="Valor da obra em escala logarítimica"))
```


Agora que temos noção de quais são as obras distoantes podemos separar estas e mostrá-las em um gráfico interativo. Veja o gráfico abaixo com mais informações sobre essas obras.


```{r message=FALSE, warning=FALSE, paged.print=FALSE}
outliers_ggplot <- 
    outliers %>% 
    mutate(mediana_meso = lapply(mesoregiao, getMedianaMeso), mediana_micro = lapply(microregiao, getMedianaMicro)) %>%
    ggplot(aes(y = valor_obra/UM_MILHAO, x = municipio, color = mesoregiao, 
               text = paste0("<b>Orgão: </b>", nome,
                             "<br><b>Valor:</b> R$", format(valor_obra/UM_MILHAO, digits = 2), " milhões", 
                             "<br><b>Mediana da mesoregião: </b>R$", mediana_meso, " milhões",
                             "<br><b>Mediana da microrregião: </b>R$", mediana_micro, " milhões",
                             "<br><b>Local da obra: </b>", breakString(descricao_localidade), 
                             "<b>Descrição: </b>", breakString(descricao_sucinta_obra)))) + 
    geom_point(alpha = .7) + 
    coord_flip() +
    labs(title = "Obras com valores extremos", x="Município", y = "Valor da obra em milões de R$")
    

plotly::ggplotly(outliers_ggplot, tooltip=c("text"))

```






