---
title: "Inconsistência Geo-PB"
date: "November 20, 2017"
output: html_document
---

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# Imports
library(knitr)
library(kableExtra)
library(tidyverse)
library(RPostgreSQL)
library(config)
#devtools::install_github("sicarul/xray")
library(xray)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# Criando conexão:
drv <- DBI::dbDriver("PostgreSQL")

con1 <- DBI::dbConnect(drv, 
  host = config::get("host"),
  port = config::get("port"),
  user = config::get("user"),
  password = config::get("password"),
  dbname = config::get("dbname1")
)

# Importando dados:
acompanhamento <- dbGetQuery(con1, "select * from t_acompanhamento")
complexo <- dbGetQuery(con1, "select * from t_complexo")       
convenio <- dbGetQuery(con1, "select * from t_convenio")         
empenhos_medicao <- dbGetQuery(con1, "select * from t_empenhos_medicao")
endereco <- dbGetQuery(con1, "select * from t_endereco")    
ente <- dbGetQuery(con1, "select * from t_ente")         
evolucao <- dbGetQuery(con1, "select * from t_evolucao")
foto_acompanhamento <- dbGetQuery(con1, "select * from t_foto_acompanhamento")
foto_medicao <- dbGetQuery(con1, "select * from t_foto_medicao")
jurisdicionado_db1 <- dbGetQuery(con1, "select * from t_jurisdicionado")     
medicao <- dbGetQuery(con1, "select * from t_medicao")   
municipio <- dbGetQuery(con1, "select * from t_municipio")          
obra <- dbGetQuery(con1, "select * from t_obra")        
origem <- dbGetQuery(con1, "select * from t_origem")             
parameter_db1 <- dbGetQuery(con1, "select * from t_parameter")
permission_db1 <- dbGetQuery(con1, "select * from t_permission")        
pessoa_db1 <- dbGetQuery(con1, "select * from t_pessoa")      
pessoafisica_db1 <- dbGetQuery(con1, "select * from t_pessoafisica")     
pessoajuridica_db1 <- dbGetQuery(con1, "select * from t_pessoajuridica")     
profile_db1 <- dbGetQuery(con1, "select * from t_profile")   
profile_permission_db1 <- dbGetQuery(con1, "select * from t_profile_permission")
recurso_proprio <- dbGetQuery(con1, "select * from t_recurso_proprio")
regularidade <- dbGetQuery(con1, "select * from t_regularidade")  
tipo_jurisdicionado_db1 <- dbGetQuery(con1, "select * from t_tipo_jurisdicionado")
user_db1 <- dbGetQuery(con1, "select * from t_user")
user_api_db1 <- dbGetQuery(con1, "select * from t_user_api")
user_profile_db1 <- dbGetQuery(con1, "select * from t_user_profile")
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# Criando conexão
con2 <- DBI::dbConnect(drv, 
  host = config::get("host"),
  port = config::get("port"),
  user = config::get("user"),
  password = config::get("password"),
  dbname = config::get("dbname2")
)

# Importando os dados
play_evolutions <- dbGetQuery(con2, "select * from play_evolutions")
contato <- dbGetQuery(con2, "select * from t_contato")
endereco <- dbGetQuery(con2, "select * from t_endereco")
gestao <- dbGetQuery(con2, "select * from t_gestao")
jurisdicionado_db2 <- dbGetQuery(con2, "select * from t_jurisdicionado")
localidade <- dbGetQuery(con2, "select * from t_localidade")
parameter_db2 <- dbGetQuery(con2, "select * from t_parameter")
periodoresponsabilidade <- dbGetQuery(con2, "select * from t_periodoresponsabilidade")
permission_db2 <- dbGetQuery(con2, "select * from t_permission")
pessoa_db2 <- dbGetQuery(con2, "select * from t_pessoa")
pessoafisica_db2 <- dbGetQuery(con2, "select * from t_pessoafisica")
pessoajuridica_db2 <- dbGetQuery(con2, "select * from t_pessoajuridica")
profile_db2 <- dbGetQuery(con2, "select * from t_profile")
profile_permission_db2 <- dbGetQuery(con2, "select * from t_profile_permission")
resto_a_pagar_temp <- dbGetQuery(con2, "select * from t_resto_a_pagar_temp")
tipo_jurisdicionado_db2 <- dbGetQuery(con2, "select * from t_tipo_jurisdicionado")
user_db2 <- dbGetQuery(con2, "select * from t_user")
user_api_db2 <- dbGetQuery(con2, "select * from t_user_api")
user_profile_db2 <- dbGetQuery(con2, "select * from t_user_profile")

```

#### Descrição dos dados

Os dados utilizados nessa análise são provenientes do banco de dados do TCE/PB, mais específicamente as bases de dados cabobranco e vigia, as quais são utilizadas na aplicação GEO Obras.

Como existem 46 tabelas nesse banco de dados, analisaremos apenas as que estão bastante atreladas as obras, visto que neste banco de dados existem também outros dados necessários para a aplicação rodar. Com isso, analisaremos a tabela obra, as que são referenciadas por esta, bem como a tabela de acompanhamento.

Vejamos a tabela de obras:

```{r}
obra %>% 
    str()
```

Na tabela de obras existem 16 colunas, onde temos: 

* id                          : O próprio id da tabela
* fk_jurisdicionado           : uma chave estrangeira para a tabela jurisdicionado
* numero_contrato             : o número do contrato da obra
* numero_obra                 : o número da obra
* descricao_sucinta_obra      : a descrição sucinta da obra
* fk_localidade               : uma chave estrangeira para a tabela de localidade
* descricao_localidade        : a descrição da localidade
* fk_tipo_obra                : uma chave estrangeira para o tipo da obra
* fk_tipo_execucao            : uma chave estrangeira para o tipo de execução
* valor_obra                  : o valor da obra
* planilha_contratada         : uma referência para a planilha da obra?
* obra_incorporavel_patrimonio: um boolean que indica se a obra é incorporável ao patrimônio
* dimensao                    : a dimensão da obra
* numero_protocolo_tramita    : o número do protocolo tramita
* fk_complexo_obras           : uma chave estrangeira para o complexo da obra
* cancelled                   : um boolean que indica se a obra foi cancelada ou não

Como falado acima, existe uma foreign key para o jurisdicionado, mas a tabela de jurisdicionado do db vigia é vazia.

```{r}
jurisdicionado_db1 %>% count()
```

Com isso, ela provavelmente se refere à tabela do db cabobranco, visto que existem observações no segundo.

```{r}
jurisdicionado_db2 %>% count()
```

A chave estrangeira fk_tipo_obra não é encontrada em nenhuma outra tabela, assim como fk_tipo_execucao. Apesar de existir uma coluna planilha_contratada na tabela obras, não foi encontrada outra tabela que contenha estas planilhas.

Vejamos a tabela de localidade, referente a chave estrangeira de obras:

```{r}
localidade %>% 
    str()
```

Na tabela de localidades também existem 16 colunas, onde temos:

* id                : o id da tabela de localidades
* uf                : a unidade federativa da localidade
* codigo_uf         : o código da unidade federativa
* mesoregiao        : a mesoregião da localidade
* codigo_mesoregiao : o código da mesoregião
* microregiao       : a microregião da localidade
* codigo_microregiao: o código da microregião
* nome              : o nome da localidade
* codigo_ibge       : o código do IGBE
* codigo_siaf       : o código do SIAF
* link_ibge         : o link do IBGE
* bandeira          : a bandeira da localidade
* brasao            : o brasão da localidade
* link_wikipedia    : o link da wikipédia referente a localidade
* esfera            : a esfera da localidade
* cancelled         : um boolean que provavelmente indica se algo da localidade foi cancelado

Vejamos a tabela de jurisdicionados, referente à chave estrangeira de obras:

```{r}
jurisdicionado_db2 %>% 
    str()
```

Na tabela de jurisdicionados existem 12 colunas, onde temos:

* id                   : o id da tabela de jurisdicionados
* pessoajuridica       : provavelmente uma chave estrangeira para a tabela de pessoa jurídica
* poder                : um código que referencia algo ao poder do jurisdicionado
* tipojurisdicionado_fk: uma chave estrangeira que referencia a tabela de tipojurisdicionado
* localidade_fk        : uma chave estrangeira para a localidade
* nome                 : o nome do jurisdicionado
* codigo_sagres        : o código do SAGRES
* previdenciario       : um boolean que indica 
* municipio_importacao : o município da importação
* tramita_id           : o id do tramita
* cancelled            : um boolean que indica que algo relativo ao jurisdicionado foi cancelado 
* esfera               : a esfera da localidade

O nome do jurisdicionado parece coincidir com a unidade gestora do banco de dados do SAGRES.

Vejamos a tabela de complexos, referente à chave estrangeira de obras:

```{r}
complexo %>% 
    str()
```

Na tabela de complexos existem 5 colunas, onde temos:

* id       : o id da tabela
* descricao: a descrição do complexo
* tipo     : o tipo do complexo
* codigo   : o código do complexo
* cancelled: um boolean que indica que algo relativo ao complexo foi cancelado

Podemos ver que a tabela de complexo complementa a de obra, visto que tem o tipo da obra. Além disso, cada complexo é referenciado por mais de uma obra, como podemos ver a seguir pela diferenca entre a chave estrangeira em obras (existem 28681 linhas) e o id em complexos (existem 720 linhas):

```{r}
obra %>% 
    filter(!is.na(fk_complexo_obras)) %>% 
    nrow()

complexo %>% 
    nrow()
```

Vejamos a tabela de acompanhamento, a que de fato contém os pontos georeferenciados.

```{r}
acompanhamento %>% 
    str()
```

Na tabela de acompanhamentos existem 5 colunas, onde temos:

* id                      : o id do acompanhamento
* tipo                    : o tipo do acompanhamento
* tipo_georeferenciamento : o tipo do georeferenciamento
* valor_georeferenciamento: o valor do georeferenciamento
* fk_obra                 : a chave estrangeira para a obra
* cancelled               : um boolean que indica que algo relativo ao acompanhamento foi cancelado
* data_cadastro           : a data de cadastro do acompanhamento

Vejamos os tipos de acompanhamento

```{r}
acompanhamento %>% 
    arrange(valor_georeferenciamento) %>% 
    head() %>% 
    kable()

acompanhamento %>% 
    filter(tipo_georeferenciamento == 1) %>% 
    arrange(valor_georeferenciamento) %>% 
    head() %>% 
    kable()

acompanhamento %>% 
    filter(tipo_georeferenciamento == 2) %>% 
    head() %>% 
    kable()

acompanhamento %>% 
    filter(tipo_georeferenciamento == 3) %>% 
    head() %>% 
    kable()
```

Vemos que a geolocalização pode ser de quatro tipos, onde o 0 é quando não existe georeferenciamento, 1 é uma lista de pares latitude e longitude, o tipo 2 é uma referência para um arquivo KML, o qual não foi encontrado na base de dados, e o tipo 3 é apenas um par de latitude e longitude.

#### Inconsistência dos dados

Vejamos os dados faltantes na tabela de obras:

```{r}
anomalies.obra <- anomalies(obra)

anomalies.obra$variables %>% 
    kable()

anomalies.obra$problem_variables %>% 
    kable()
```

Vemos que exceto o número do protocolo tramita em que 0.05% das observações são nulas, nenhuma outra coluna tem observações nulas, porém a porcentagem de zeros chega a 97,36% na dimensão e 79,06% no valor da obra. Apesar de acusar 99,1% de zeros na coluna de obras canceladas, é uma coluna com tipo lógico, faz sentido que a maioria das obras não sejam canceladas, o que também acontece na coluna de obras incorporáveis ao patrimônio, onde acusa que 91,29% das obras tem valor zero.

Apesar da maioria das colunas não apresentarem valores nulos ou zeros, muitas delas possuem valores sem significado, por exemplo:

```{r}
obra %>% 
    group_by(numero_contrato) %>% 
    summarise(quantidade = n()) %>% 
    arrange(-quantidade) %>% 
    head() %>% 
    kable()
```

Existem 18567 números de contrato 0000, assim como 30 com valor "-".

Do mesmo modo, a coluna referente à descrição sucinta da obra tem alguns valores não nulos, mas sem significado:
```{r}
obras.sem.descricao <- obra %>% 
    filter(str_count(descricao_sucinta_obra, "[:alpha:]|[:blank:]") / nchar(descricao_sucinta_obra) < 0.6)

obras.sem.descricao %>% 
    select(id, fk_jurisdicionado, numero_contrato, numero_obra, descricao_sucinta_obra, fk_localidade) %>% 
    head() %>% 
    kable()
```

```{r}
(obras.sem.descricao %>% count()) / (obra %>% count()) * 100
```


Onde existem 1.5% de dados com mais de 40% da palavra composta por caracteres diferente do alfabeto.

Da mesma forma, a descrição da localidade tem vários valores sem significados:

```{r}
obras.sem.localidade <- obra %>% 
    filter(str_count(descricao_localidade, "[:alpha:]|[:blank:]") / nchar(descricao_localidade) < 0.6)

obras.sem.localidade %>% 
    select(id, fk_jurisdicionado, numero_contrato, numero_obra, descricao_sucinta_obra, fk_localidade) %>% 
    head() %>% 
    kable()

(obras.sem.localidade %>% count()) / (obra %>% count()) * 100
```

É possível ver que 1,58% das obras tem localidade composta por mais de 40% de caracteres diferente do alfabeto.

Vejamos os dados faltantes de jurisdicionados:

```{r}
anomalies.jurisdicionado <- anomalies(jurisdicionado_db2)

anomalies.jurisdicionado$variables %>% 
    kable()

anomalies.jurisdicionado$problem_variables %>% 
    kable()
```

Vemos que em 28,24% dos dados, o código do sagres é vazio e em 9,73% dos dados da esfera, 0,76% da chave estrangeira da localidade e 0,38% do município de importação são nulos. Da mesma forma que o anterior, as colunas previdenciario e cancelled são do tipo boolean, logo, faz sentido a maior parte deles terem apenas um valor.

Vejamos agora os dados das localidades:

```{r}
anomalies.localidade <- anomalies(localidade)

anomalies.localidade$variables %>% 
    kable()

anomalies.localidade$problem_variables %>% 
    kable()
```

Vemos que várias colunas da localidade tem 95,98% dos valores faltantes, como codigo_ibge, esfera, bandeira, brasao, link_ibge e link_wikipedia.

Agora pelo complexo:

```{r}
anomalies.complexo <- anomalies(complexo)

anomalies.complexo$variables %>% 
    kable()

anomalies.complexo$problem_variables %>% 
    kable()
```

Vemos que os dados de complexo parecem ser bem completos, não tendo dados faltantes, visto que a coluna cancelled é um boolean, onde nenhum complexo foi cancelado. Apesar disso, duas descrições não fazem sentido: 

```{r}
complexo %>% 
    filter(str_count(descricao, "[:alpha:]|[:blank:]") / nchar(descricao) < 0.6) %>% 
    kable()
```

Além disso, é possível ver que existe que várias obras referenciam um mesmo complexo. Podemos ver a seguir os complexos com mais obras:

```{r}
obra %>% 
    group_by(fk_complexo_obras) %>% 
    summarise(quantidade = n()) %>% 
    arrange(-quantidade) %>% 
    head() %>% 
    left_join(complexo, by = c("fk_complexo_obras" = "id")) %>% 
    kable()
```

Vemos que o complexo com mais obras é fictício, visto que a descrição é IMPORTAÇÃO GEOPB.

Por último, vejamos os dados faltantes da tabela de acompanhamento:

```{r}
anomalies.acompanhamento <- anomalies(acompanhamento)

anomalies.acompanhamento$variables %>% 
    kable()

anomalies.acompanhamento$problem_variables %>% 
    kable()
```

Vemos que tanto o tipo do georeferenciamento, quanto o valor do mesmo em 98,9% das linhas tem valor igual a zero.

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
dbDisconnect(con1)
dbDisconnect(con2)
```

---

