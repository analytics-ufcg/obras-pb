---
title: "Mapas Temáticos"
output: 
    html_document:
        toc: true
        toc_float: true
        fig_width: 10
        fig_heigth: 8 
---

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(RColorBrewer)
library(RPostgreSQL)
library(knitr)
library(leaflet)
library(rgdal)
library(rgeos)
library(sp)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
drv <- DBI::dbDriver("PostgreSQL")

con1 <- DBI::dbConnect(drv, 
  host = config::get("host"),
  port = config::get("port"),
  user = config::get("user"),
  password = config::get("password"),
  dbname = config::get("dbname1")
)

obra <- dbGetQuery(con1, "select * from t_obra")        
acompanhamento <- dbGetQuery(con1, "select * from t_acompanhamento")
complexo <- dbGetQuery(con1, "select * from t_complexo")
evolucao <- dbGetQuery(con1, "select * from t_evolucao")

con2 <- DBI::dbConnect(drv, 
  host = config::get("host"),
  port = config::get("port"),
  user = config::get("user"),
  
  password = config::get("password"),
  dbname = config::get("dbname2")
)

jurisdicionado_db2 <- dbGetQuery(con2, "select * from t_jurisdicionado")
localidade <- dbGetQuery(con2, "select * from t_localidade")

tipos.das.obras <- read.csv("tipos_obra.csv")
municipios.pb <- read.csv("municipios_pb.csv")

mapa_paraiba <- readOGR("mapa_paraiba_ibge/Municipios.shp")
```

## Introdução

Nesta análise vamos identificar possíveis mapas temáticos para incorporar futuramente ao GeoPB, utilizando dados georreferenciados de obras da Paraíba. Para fazê-la, utilizaremos apenas dados de obras a partir de 2013. Quando utilizar o valor da obra, consideraremos apenas valores acima de R$ 1000,00 e quando utilizar a dimensão, consideraremos apenas obras com dimensão acima de 50 da respectiva unidade.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obra.georref <- acompanhamento %>% 
    left_join(obra, by = c("fk_obra" = "id")) %>% 
    left_join(localidade, by = c("fk_localidade" = "id"))
```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Associa para cada obra uma localização georreferenciada

## Coloca o centróide no lugar de uma dista de localizações 

obra.filtrada <- obra.georref %>% 
    filter(tipo_georeferenciamento != 0)

is.dentro.pb <- function(lat,lon) {
    lon.min <- -38.770132
    lat.min <- -8.316999
    lon.max <- -34.786624
    lat.max <- -5.995412
    return(lon.min < lon && lon < lon.max && lat.min < lat && lat < lat.max)
}

is.dentro.municipio <- function(lat, lon, codigo_ibge) {
    mapa_municipio <- subset(mapa_paraiba, GEOCODIG_M == codigo_ibge)
    point <- data.frame(lat = lon, lon = lat)
    point_spatial <- SpatialPoints(point, proj4string = CRS(proj4string(mapa_paraiba)))
    #plot(mapa_municipio)
    #plot(point_spatial, add=T, col="red")
    return(gContains(mapa_municipio, point_spatial))
    #teste <- over(point_spatial, mapa_municipio) PEGA A LINHA DO DATA FRAME DO MAPA QUE CORRESPONDE AO MUNICIPIO DO PONTO
}

```
    
    
    
```{r, warning=FALSE, message=FALSE, echo=FALSE}
coord_divide <- function(value, parameter) {
    return(
        ifelse(value < parameter, 
               coord_divide(value / 10, parameter),
               value)
    )
}

corrige.coords <- function(coord1, coord2){
    coord1 <- if_else(coord1 > 0, coord1 * -1, coord1)
    coord2 <- if_else(coord2 > 0, coord2 * -1, coord2)
    
    lat <- max(coord1, coord2)
    lon <- min(coord1, coord2)
    
    lat <- coord_divide(lat, -10)
    lon <- coord_divide(lon, -100)
    
    return(c(lat = lat, lon = lon))
}

format.geo <- function(mat) {
    mat.pb <- data.frame(mat) %>% 
        rowwise() %>% 
        mutate(
            lat = corrige.coords(X1, X2)["lat"],
            lon = corrige.coords(X1, X2)["lon"]
        ) %>% 
        rowwise() %>% 
        filter(is.dentro.pb(lat, lon))
    
    coord1 <- mean(mat.pb$X1)
    coord2 <- mean(mat.pb$X2)
    
    coords <- corrige.coords(coord1, coord2)
    
    lat <- coords[1]
    lon <- coords[2]
    
    paste(lat,lon, sep = ",")
}

centroide <- function(localizacao) {
    
    coords <- tryCatch( 
        {
            parsed.mat <- matrix(jsonlite::fromJSON(localizacao), ncol = 2)
            
            return(format.geo(parsed.mat))
        },
        error=function(cond) {
            tryCatch(
                {
                    lista.loc.format <- strsplit(localizacao, "\\],")[[1]]
                    lista.loc.format <- str_replace_all(lista.loc.format, "\\[|\\]", "")
                    lista.coord <- unlist(strsplit(lista.loc.format, ","))
                    lista.coord <- trimws(lista.coord, which = "both")
                    lista.coord.format <- lapply(lista.coord, function(d){
                        as.numeric(unlist(strsplit(d, " "))[1])
                        })
                    parsed.matrix <- matrix(unlist(lista.coord.format), ncol = 2, byrow = TRUE)
                    
                    return(format.geo(parsed.matrix))
                },
                error = function(cond) {
                    return(localizacao)
                }
            )
            return(localizacao)
        }
    )
    coords
}

paleta.de.cores <- function(paleta = "YlOrRd", dado) {
    colors <- colorNumeric(paleta, domain = c(min(dado, na.rm = T), max(dado, na.rm = T)))
}

cria.mapa <- function(dado, valor.municipio, tooltip, janela, cores, titulo) {
    dado %>% 
        leaflet() %>% 
        addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
        addPolygons(opacity = 0.5, 
                  weight = 1, 
                  fillColor = colors(valor.municipio),
                  color = "black", 
                  label = tooltip,
                  popup = janela,
                  fillOpacity = 1) %>%
        addLegend(position = "bottomright", pal = cores, values = valor.municipio,
                title = titulo,
                opacity = 1)
}

obra.georref.corrigido <- obra.filtrada %>% 
    rowwise() %>% 
    mutate(
        valor_georeferenciamento = ifelse(tipo_georeferenciamento != 1 & tipo_georeferenciamento != 3, 
                                          valor_georeferenciamento, 
                                          centroide(valor_georeferenciamento))
    ) %>%
    filter(
        tipo_georeferenciamento != 2
    ) %>% 
    separate(
        valor_georeferenciamento, 
        c("lat", "lon"),
        sep = ",",
        remove = FALSE,
        convert = TRUE
    )

obra.georref.corrigido <- obra.georref.corrigido %>%
    filter(!is.na(lat) & !is.na(lon) & codigo_ibge != 0 & !is.na(codigo_ibge)) %>%
    filter(
        is.dentro.pb(lat,lon)
    ) %>% mutate(
        dentro_municipio =  is.dentro.municipio(lat, lon, codigo_ibge)
    )


obra.georref.centroide.sumarizado <- obra.georref.corrigido %>%
    group_by(fk_obra) %>%
    mutate(lat = mean(lat), lon = mean(lon)) %>%
    select(-valor_georeferenciamento) %>% 
    filter(!duplicated(fk_obra))

#write_csv(obra.georref.centroide.sumarizado, "obras_georref_centroide_sumarizadas.csv")
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
municipios <- data.frame(codigo_ibge = mapa_paraiba$GEOCODIG_M, lat = coordinates(mapa_paraiba)[,2], lon = coordinates(mapa_paraiba)[,1])

obras.2013 <- obra %>% 
    left_join(localidade, by = c("fk_localidade" = "id")) %>% 
    left_join(evolucao, by = c("id" = "fk_obra")) %>% 
    mutate(ano = lubridate::year(data_inicio_obra)) %>% 
    filter(
        ano >= 2013
    ) %>% 
    left_join(tipos.das.obras, by = c("fk_tipo_obra" = "id")) %>% 
    left_join(municipios, by = "codigo_ibge") %>% 
    left_join(obra.georref.centroide.sumarizado %>% select(id,lat,lon,dentro_municipio), by = c("id" = "fk_obra")) %>% 
    mutate(
        lat = ifelse(is.na(lat.y), lat.x, lat.y), 
        lon = ifelse(is.na(lon.y), lon.x, lon.y),
        is.inputado = ((is.na(lat.y) & is.na(lon.y)) | (!is.na(dentro_municipio) & dentro_municipio == FALSE))
    ) %>% select(-lat.x, -lat.y, -lon.x, -lon.y)
    
obras.filtradas.valor <- obras.2013 %>% 
    filter(valor_obra > 1000, valor_obra < 1000000000)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Municípios que mudaram de nome ou que estão com o nome errado
levels_mapa = levels(mapa_paraiba@data$Nome_Munic)
levels_mapa[51] = "Tacima"
levels_mapa[156] = "Quixaba"
levels_mapa[173] = "Joca Claudino"
levels_mapa[179] = "São Domingos de Pombal"
levels_mapa[200] = "São Vicente do Seridó"

levels(mapa_paraiba@data$Nome_Munic) = levels_mapa
```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Vamos elencar as variáveis disponíveis para mostrar nos mapas:
# 
# * Localidade
#     + Mesoregião
#     + Microregião
#     + Nome
#     + georreferencia
# * Valor
# * Dimensão
# * Tipo da obra
#     + Nome
#     + Unidade de medida
# * Obra incorporável ao patrimônio
# * Cancelada
# * Data:
#     + Ano
#     + Início da obra
#     + Previsão de conclusão
# * Andamento
```

## Quantidade de obras 2013-2017

Vejamos primeiramente a quantidade de obras por município, onde os detalhes podem ser vistos clicando no município:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
mapa_paraiba_quantidade_obras <- mapa_paraiba

quantidade.obras.municipio <- obras.2013 %>% 
    group_by(nome.x, codigo_ibge) %>% 
    summarise(
        valor.mediano = median(valor_obra),
        qtde.obras = n(),
        qtde.obras.log = log(qtde.obras)
    )

mapa_paraiba_quantidade_obras@data <- mapa_paraiba@data %>%
  left_join(quantidade.obras.municipio,
            by = c("GEOCODIG_M" = "codigo_ibge"))

colors <- paleta.de.cores(dado = mapa_paraiba_quantidade_obras@data$qtde.obras.log)

cria.mapa(
    mapa_paraiba_quantidade_obras, 
    mapa_paraiba_quantidade_obras@data$qtde.obras.log, 
    mapa_paraiba_quantidade_obras@data$Nome_Munic, 
    paste('Município: ', mapa_paraiba_quantidade_obras@data$Nome_Munic, '</br>Custo mediano das obras: R$ ', format(mapa_paraiba_quantidade_obras@data$valor.mediano, big.mark=".", decimal.mark = ",", nsmall = 2, scientific = FALSE), '</br>Número de obras: ', mapa_paraiba_quantidade_obras@data$qtde.obras), 
    colors, 
    "Log da quantidade de <br/> obras por município"
    )
```

É possível ver que o município de Manaíra se destaca dos demais, por ser uma cidade pequena e ter uma grande quantidade de obras. O motivo de acontecer isso é porque nesta cidade existem várias observações para um mesmo contrato, ou seja, existem vários casos de ter um mesmo contrato, mas a obra ocorre em várias ruas, seja para calçamento, rede de esgotamento, entre outros tipos de obra.

## Cidades que mais gastam 2013-2017

Vejamos as cidades que mais gastam com obras na Paraíba:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obras.filtradas.valor %>% 
    group_by(nome.x) %>%
    summarise(
        valor.total = sum(valor_obra),
        lat = mean(lat),
        lon = mean(lon)
    ) %>% 
    mutate(
        popup = paste(
            "Município:", nome.x,
            "</br>Valor total em obras: R$", format(valor.total, big.mark=".", decimal.mark = ",", nsmall = 2, scientific = FALSE)
        )
    ) %>% 
    leaflet() %>% 
    addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
    addCircles(
        weight = 1, 
        radius = ~sqrt(valor.total), 
        popup = ~popup
    )
```

## Gasto por habitante 2013-2017

Vejamos agora um o valor gasto em obras por habitante em cada município, onde os detalhes podem ser vistos clicando no município:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
gasto.por.habitante.por.municipio <- obras.filtradas.valor %>% 
    group_by(codigo_ibge) %>% 
    summarise(valor.total.obras = sum(valor_obra)) %>% 
    left_join(municipios.pb %>% rename("codigo_ibge" = "Código", "populacao" = "População.estimada...pessoas") %>% select(codigo_ibge, populacao),
              by = "codigo_ibge") %>% 
    mutate(
        gasto.por.habitante = valor.total.obras / populacao,
        gasto.por.habitante.log = log(gasto.por.habitante)
    )

mapa_paraiba_gasto_habitante <- mapa_paraiba

mapa_paraiba_gasto_habitante@data <- mapa_paraiba@data %>%
  left_join(gasto.por.habitante.por.municipio,
            by = c("GEOCODIG_M" = "codigo_ibge"))

colors <- paleta.de.cores(dado = mapa_paraiba_gasto_habitante@data$gasto.por.habitante.log)

cria.mapa(
    mapa_paraiba_gasto_habitante, 
    mapa_paraiba_gasto_habitante@data$gasto.por.habitante.log, 
    mapa_paraiba_gasto_habitante@data$Nome_Munic, 
    paste("Município: ", mapa_paraiba_gasto_habitante@data$Nome_Munic, "</br>Valor em obras por habitante: R$", format(mapa_paraiba_gasto_habitante@data$gasto.por.habitante, big.mark=".", decimal.mark = ",", nsmall = 2, scientific = FALSE), "</br>Valor total das obras: R$", format(mapa_paraiba_gasto_habitante@data$valor.total.obras, big.mark=".", decimal.mark = ",", nsmall = 2, scientific = FALSE), "</br>Quantidade de habitante: ", mapa_paraiba_gasto_habitante@data$populacao), 
    colors, 
    "Log do valor gasto em </br> obras por habitante"
    )
```

Vejamos as obras de São Francisco mais caras:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obras.filtradas.valor %>% 
    filter(nome.x == "São Francisco") %>% 
    arrange(-valor_obra) %>% select(nome.x, ano, valor_obra, descricao_sucinta_obra, descricao_localidade) %>%
    top_n(5) %>% 
    kable()
```

Provavelmente o gasto por habitante com obras foi elevado devido à primeira obra, a qual custou 28 mi de reais.

## Obras georreferenciadas 2013-2017

Vejamos agora o mapa de pontos das obras georreferenciadas, onde os detalhes podem ser vistos clicando na obra:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obra.georref.centroide.sumarizado %>% 
    left_join(
        evolucao %>% 
            mutate(ano = lubridate::year(data_inicio_obra)) %>% 
            select(fk_obra, ano),
        by = c("id" = "fk_obra")
    ) %>% 
    filter(ano >= 2013) %>% 
    mutate(
        label = str_to_upper(
            ifelse(
                nchar(descricao_sucinta_obra) <= 30,
                descricao_sucinta_obra,
                paste0(substr(descricao_sucinta_obra, 1, 30), "...")
            )
        ),
        popup = paste(
            "Descrição:", str_to_upper(descricao_sucinta_obra), "</br>",
            "Cidade:", nome, "</br>",
            "Valor pago: R$", format(valor_obra, big.mark=".", decimal.mark = ",", nsmall = 2, scientific = FALSE)
        )
    ) %>% 
    leaflet() %>% 
        addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
        setView(lng = -36.623, lat = -7.548, zoom = 7)  %>% 
        addTiles() %>%
        addMarkers(~lon, ~lat, label = ~label, 
                 popup = ~popup,
                 clusterOptions = markerClusterOptions())
```

### Dados inválidos inputados

E agora os pontos georreferenciados, substituindo a localização pelo centro da cidade quando o dado é inexistente, onde os detalhes podem ser vistos clicando na obra:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obras.2013 %>% 
    mutate(
        label = str_to_upper(
            ifelse(
                nchar(descricao_sucinta_obra) <= 30,
                descricao_sucinta_obra,
                paste0(substr(descricao_sucinta_obra, 1, 30), "...")
           )
        ),
        popup = paste(
            "Descrição:", str_to_upper(descricao_sucinta_obra), "</br>",
            "Cidade:", nome.x, "</br>",
            "Valor pago: R$", format(valor_obra, big.mark=".", decimal.mark = ",", nsmall = 2, scientific = FALSE)
        )
    ) %>% 
    leaflet() %>% 
        addProviderTiles(providers$OpenStreetMap.Mapnik) %>%
        setView(lng = -36.623, lat = -7.548, zoom = 7)  %>% 
        addTiles() %>%
        addMarkers(~lon, ~lat, label = ~label, 
             popup = ~popup,
             clusterOptions = markerClusterOptions())
```

### Obras não georreferenciadas

Vejamos os municípios que não georreferenciam suas obras, onde os detalhes podem ser vistos clicando na obra:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
municipios.nao.georref.prop <- obras.2013 %>% 
    group_by(codigo_ibge, nome.x) %>% 
    summarise(
        possui.georref.mas.tem.coordenadas.fora.municipio = 
            sum(
                ifelse(!is.na(dentro_municipio) & dentro_municipio == FALSE, 1, 0)
            ),
        total.nao.georref = n(),
        qtde.nao.georref = sum(is.inputado),
        prop.nao.georref = (qtde.nao.georref / total.nao.georref) * 100
    )
    
mapa_paraiba_nao_georreferenciada <- mapa_paraiba

mapa_paraiba_nao_georreferenciada@data <- mapa_paraiba_nao_georreferenciada@data %>%
  left_join(municipios.nao.georref.prop,
            by = c("GEOCODIG_M" = "codigo_ibge"))

colors <- paleta.de.cores(dado = mapa_paraiba_nao_georreferenciada@data$prop.nao.georref)
municipios.nao.georref.prop.top.3 <- municipios.nao.georref.prop %>% 
    filter(codigo_ibge != 0) %>%
    arrange(prop.nao.georref) %>%
    head(3) %>%
    left_join(municipios, by = "codigo_ibge")
    


trofeu.icon <- icons(
    iconUrl = "http://www.freeiconspng.com/img/30572",
   iconWidth = 38, iconHeight = 95,
  iconAnchorX = 19, iconAnchorY = 94
    
    )

cria.mapa(
    mapa_paraiba_nao_georreferenciada, 
    mapa_paraiba_nao_georreferenciada@data$prop.nao.georref, 
    mapa_paraiba_nao_georreferenciada@data$Nome_Munic, 
    paste0("Município: ", mapa_paraiba_nao_georreferenciada@data$Nome_Munic,
           "</br>Total de obras: ", mapa_paraiba_nao_georreferenciada@data$total.nao.georref,
           "</br>Quantidade de obras não georreferenciadas: ", mapa_paraiba_nao_georreferenciada@data$qtde.nao.georref,
           "</br>Obras com coordenadas fora do município: ",      
           mapa_paraiba_nao_georreferenciada@data$possui.georref.mas.tem.coordenadas.fora.municipio,
           "</br>Proporção de obras não georreferenciadas em %: ", round(mapa_paraiba_nao_georreferenciada@data$prop.nao.georref, 2), "%"
           ), 
    colors, 
    "Proporção de obras não</br> georreferenciadas em %") %>% 
    
    addMarkers(lng = ~lon, lat = ~lat, icon = trofeu.icon, data = municipios.nao.georref.prop.top.3)


```

Vemos que a maior parte das obras não são georreferenciadas nos municípios paraibanos entre 2013 e 2017, onde apenas 5 municípios tem mais de 10% das obras georreferenciadas.

## Custo efetivo 2013-2017

Agora vamos verificar o custo efetivo das obras, selecionando apenas as obras com valor maior que 1000 reais e dimensão maior que zero.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obras.2013.custo.efetivo <- obra %>% 
    left_join(localidade, by = c("fk_localidade" = "id")) %>% 
    left_join(evolucao, by = c("id" = "fk_obra")) %>% 
    mutate(ano = lubridate::year(data_inicio_obra)) %>% 
    filter(
        ano >= 2013 &
        valor_obra > 1000
    ) %>% 
    left_join(tipos.das.obras %>% mutate(tipo_obra = nome) %>% select(-nome), by = c("fk_tipo_obra" = "id"))
```

Para isso, vamos ver os cinco tipos de obra mais executados, visto que faz mais sentido comparar o custo efetivo de obras do mesmo tipo.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obras.2013.custo.efetivo %>%
    group_by(tipo_obra) %>%
    filter(dimensao > 0) %>%
    count() %>%
    arrange(-n) %>% 
    head(5) %>% 
    kable()
```

### Pavimentação de paralelepípedo

Como o tipo mais frequente é PAVIMENTAÇÃO PARALEPÍPEDO, vamos selecionar apenas este tipo e obras com dimensão maior do que 50m2.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
obras.2013.pavimentacao <- obras.2013.custo.efetivo %>%
    filter(tipo_obra == 'PAVIMENTAÇÃO PARALEPÍPEDO' & dimensao > 50) %>%
    select(valor_obra, dimensao, nome, descricao_sucinta_obra) %>%
    mutate(custo.efetivo = valor_obra/dimensao) %>% 
    group_by(nome) %>%
    summarise(
        custo.efetivo = median(custo.efetivo),
        custo.efetivo.log = log(custo.efetivo)
    )
```

Vejamos agora o mapa do custo efetivo por metro quadrado das obras de pavimentação em todo o estado.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
mapa_paraiba_custo_efetivo <- mapa_paraiba

mapa_paraiba_custo_efetivo@data <- mapa_paraiba@data %>%
    left_join(obras.2013.pavimentacao,by = c("Nome_Munic" = "nome"))

colors <- paleta.de.cores(dado = mapa_paraiba_custo_efetivo@data$custo.efetivo.log)

cria.mapa(
    mapa_paraiba_custo_efetivo,
    mapa_paraiba_custo_efetivo@data$custo.efetivo.log, 
    mapa_paraiba_custo_efetivo@data$Nome_Munic, 
    paste('Município: ', mapa_paraiba_custo_efetivo@data$Nome_Munic, '</br>Custo efetivo: R$', format(mapa_paraiba_custo_efetivo@data$custo.efetivo, digits = 2, big.mark=".", decimal.mark = ",", scientific = FALSE)), 
    colors, 
    "Log do custo efetivo </br> mediano das obras"
    )
```

Obs: A cidade que possui o maior custo efetivo do estado (São José de Princesa) parece ser fruto de dados errôneos, uma vez que este município efetuou apenas uma obra de pavimentação desde 2013 e esta obra foi orçada no valor R$368.346,40 e a dimensão da mesma consta como apenas 100 metros quadrados.

---